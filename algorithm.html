<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>2023-2 UROP</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    </head>
    <body>
        <nav class="navbar navbar-expand-lg navbar-dark" style="background-color: rgb(0,0,0);">
            <div class="container-fluid">
                <a class="navbar-brand" href="main.html">UROP</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a class="nav-link active" aria-current="page" href="#">Home</a>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            개발 가이드
                            </a>
                            <ul class="dropdown-menu">
                                <li><a class="dropdown-item" href="#">환경설정</a></li>
                                <li><a class="dropdown-item" href="#">클라이언트</a></li>
                                <li><a class="dropdown-item" href="#">서버</a></li>
                                <li><a class="dropdown-item" href="#">알고리즘</a></li>
                            </ul>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            앱 설명
                            </a>
                            <ul class="dropdown-menu">
                                <li><a class="dropdown-item" href="#">앱 빌드 방법</a></li>
                                <li><a class="dropdown-item" href="#">앱 구동 모습 설명</a></li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>

        <div class="p-5 mb-4 bg-light rounded-3">
            <div class="container-fluid py-5">
                <h1 class="display-5 fw-bold">Client - 스도쿠 게임 만들기</h1>
                <p class="col-md-8 fs-4">개발자를 위한 학습 플랫폼 개발 💥 </p>
                <h1>배치는 어떻게 하고 디자인은 어떻게 할지 정하죠</h1>
            </div>
        </div>

        <hr>
        <div style="margin: 5% 5%;">
            <div style="margin: 5% 0%; background-color: rgb(55, 55, 55); color: rgb(242, 253, 253); padding: 1rem; border-radius: 1.5rem;">
        <h1>알고리즘 개발 가이드</h2>

        <p>
        <b>알고리즘 코드를 개발하기 위해 아래의 개발 가이드를 따라 주세요.</b>
        <br>
        <b>알고리즘은 다양한 언어로 개발이 가능합니다! 예시는 c++ 코드로 진행됩니다.</b>
        <br>
        <b>개발에 어려움을 겪고 있다면 예제 코드를 그대로 사용해 보아도 좋습니다.</b>
        <br>
        <b>전체 코드를 이용하여 작은 부분만 바꾸어 보며 코드를 이해하고 그 후에 다시 만들어볼 수 있습니다.</b>
        <br>
        스도쿠에 필요한 알고리즘을 개발해봅시다!
        <br>
    </div>
    
    <div style="margin: 5% 0%;">
        <h2>1. 스도쿠 배열 만드는 알고리즘 만들기</h2>
    <p>
        <br><br>
        스도쿠 게임을 진행하려면 스도쿠 게임 배열이 필요합니다.<br><br>
        이 스도쿠 배열은 9X9모양의 2차원 배열로 이루어져 있습니다.<br><br>
        스도쿠 게임 배열을 만들어주는 알고리즘을 작성해 봅시다!<br><br>
        다음과 같이 차례대로 코드를 만들어 봅시다.<br><br>

        <br><br>make_arr.cpp 파일을 생성합니다.
       
        스도쿠 배열을 만드는 흐름은 다음과 같습니다. <br><br><br>

        1. 스도쿠 그리드의 대각선 방향의 3X3 박스를 채움 <br><br>
        2. 나머지 박스를 채움<br><br>
        3. 채워진 박스에서 무작위로 숫자를 지움<br><br><br>


        이를 구현하기 위해 다음과 같은 종류의 메소드들을 구현해 봅시다.
        <br><br>

        1. 스도쿠 그리드에서 3X3 박스를 채우는 메소드<br><br>
        2. 주어진 위치에 숫자를 채울 수 있는지 판단하는 메소드<br><br>
        3. 무작위로 그리드에서 숫자를 제거하는 메소드<br><br>

        <br><br>
        스스로 한번 개발에 도전해 봅시다. <br><br>
        어렵다면 아래 코드를 참고해서 개발을 해봅시다.<br><br>
        예제 코드입니다.
        <pre style = "background-color: rgb(225, 225, 225);">
            <code>
    #include <iostream>
    #include <cstdlib>
    #include <ctime>
    
    using namespace std;
    
    class Sudoku {
    public:
        int grid[9][9];
        int K;
        int N;
    
        Sudoku(int K) :N(9){
            this->K = K;
            for (int i = 0; i < 9; ++i)
                for (int j = 0; j < 9; ++j)
                    grid[i][j] = 0;
        }
    
        void fillValues() {
            fillDiagonal();
            fillRemaining(0, 3);
            removeKDigits();
        }
    
        void fillDiagonal() {
            for (int i = 0; i < 9; i = i + 3)
                fillBox(i, i);
        }
    
        bool unUsedInBox(int rowStart, int colStart, int num) {
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    if (grid[rowStart + i][colStart + j] == num)
                        return false;
            return true;
        }
    
        void fillBox(int row, int col) {
            int num;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    do {
                        num = randomGenerator(N);
                    }
                    while (!unUsedInBox(row, col, num));
                    grid[row + i][col + j] = num;
                }
            }
        }
    
        int randomGenerator(int num) {
            return (rand() % num) + 1;
        }
    
        bool CheckIfSafe(int i, int j, int num) {
            return (unUsedInRow(i, num) && unUsedInCol(j, num) &&
                unUsedInBox(i - i % 3, j - j % 3, num));
        }
    
        bool unUsedInRow(int i, int num) {
            for (int j = 0; j < 9; j++)
                if (grid[i][j] == num)
                    return false;
            return true;
        }
    
        bool unUsedInCol(int j, int num) {
            for (int i = 0; i < 9; i++)
                if (grid[i][j] == num)
                    return false;
            return true;
        }
    
        bool fillRemaining(int i, int j) {
            if (i == 8 && j == 9)
                return true;
    
            if (j == 9) {
                i++;
                j = 0;
            }
    
            if (grid[i][j] != 0)
                return fillRemaining(i, j + 1);
    
            for (int num = 1; num <= 9; num++) {
                if (CheckIfSafe(i, j, num)) {
                    grid[i][j] = num;
                    if (fillRemaining(i, j + 1))
                        return true;
                }
                grid[i][j] = 0;
            }
            return false;
        }
    
        void removeKDigits() {
            int count = K;
            while (count) {
                int cellId = randomGenerator(9 * 9) - 1;
                int i = (cellId / 9);
                int j = cellId % 9;
    
                if (grid[i][j] != 0) {
                    count--;
                    grid[i][j] = 0;
                }
            }
        }
    };
    
    int main() {
        int K = 50;
        srand(time(0));
        Sudoku sudoku(K);
        sudoku.fillValues();
        return sudoku.grid;
    }
            </code>
        </pre>
<br><br><br>
코드에 대한 설명입니다.<br><br>
1. Sudoku 클래스를 선언합니다. 이 클래스는 스도쿠 게임을 구현하며, 주요 변수 및 메서드를 포함하고 있습니다.<br><br>
grid는 9x9 스도쿠 그리드를 나타냅니다.<br>
K는 그리드에서 제거할 숫자의 개수입니다.<br>
N은 스도쿠 그리드의 크기입니다.<br><br>
2. 생성자에서는 K 값을 초기화하고, 그리드를 0으로 채웁니다.<br><br>
3. fillValues 메서드에서는 스도쿠 그리드를 채우는 과정을 시작합니다. 이 메서드는 대각선에 3x3 박스를 채우고, 나머지 위치에 숫자를 채운 후, K개의 숫자를 제거하는 과정을 거칩니다.<br><br>
4. fillDiagonal 메서드에서는 스도쿠 그리드의 대각선에 위치한 3x3 박스를 채웁니다. 이는 스도쿠 게임의 특성상 각 3x3 박스는 서로 독립적이므로, 먼저 채우고 시작합니다.<br><br>
5. fillBox 메서드에서는 주어진 위치의 3x3 박스를 채웁니다. 이때 unUsedInBox 메서드를 사용하여 해당 박스에 이미 사용된 숫자가 아닌지 확인하고, 사용되지 않은 숫자를 박스에 채웁니다.<br><br>
6. fillRemaining 메서드에서는 나머지 그리드를 채웁니다. 이 메서드는 재귀적으로 호출되며, 각 위치에 대해 CheckIfSafe 메서드를 이용해 안전하게 숫자를 채울 수 있는지 확인합니다.<br><br>
7. CheckIfSafe 메서드에서는 주어진 위치에 숫자를 채울 수 있는지 확인합니다. 이때 unUsedInRow, unUsedInCol, unUsedInBox 메서드를 사용해 해당 숫자가 행, 열, 박스에 이미 사용되지 않았는지 확인합니다.<br><br>
8. removeKDigits 메서드에서는 그리드에서 무작위로 K개의 숫자를 제거합니다. 이렇게 하여 스도쿠 퍼즐이 완성됩니다.<br><br>
9. main 함수에서는 K 값을 설정하고, 스도쿠 퍼즐을 생성하는 과정을 수행합니다.<br><br>
<br><br>
    </p>
    </div>
    <div style="margin: 5% 0%;">
    <h2>2. 스도쿠 정답 만들기</h2>
    <br><br>
    다음으로 정답 배열을 만드는 알고리즘을 만들어 봅시다.
    <br><br>ssudo.cpp 파일을 생성합니다.

    <br><br>
    스도쿠 정답 배열을 만들려면 스도쿠 문제 배열을 받아서 배열에 숫자를 넣어야 합니다.<br><br>
    스도쿠 정답 배열을 만들어주는 알고리즘을 작성해 봅시다!<br><br>
    다음과 같이 차례대로 코드를 만들어 봅시다.<br><br>
    
    스도쿠 정답 배열을 만드는 흐름은 다음과 같습니다. <br><br><br>

    1. 스도쿠 문제 배열을 받음.<br><br>
    2. 스도쿠 문제 배열의 해결 가능 여부를 판단함.<br><br>
    3. 스도쿠 문제 배열에 빈 칸에 숫자를 채움.<br><br><br>


    이를 구현하기 위해 다음과 같은 종류의 메소드들을 구현해 봅시다.
    <br><br>

    1. 스도쿠 문제 해결 가능 여부 판단 메소드<br><br>
    2. 주어진 위치에 숫자를 채울 수 있는지 판단하는 메소드<br><br>
    3. 스도쿠 문제 배열을 채우는 메소드<br><br>

    <br><br>
    스스로 한번 개발에 도전해 봅시다. <br><br>
    어렵다면 아래 코드를 참고해서 개발을 해봅시다.<br><br>
    예제 코드입니다.
    <br><br>
    <pre style = "background-color: rgb(225, 225, 225);">
        <code>
        #include <iostream>
        using namespace std;
        int grid[9][9];
        
        bool isPossible(){
            int row, col;
            int filled_cell = 0;
            
            for(row =0; row<9; row++){
                for(col=0; col<9; col++){
                    if(grid[row][col] != 0) filled_cell++;
                }
            }
            return filled_cell >= 17;
        }
        // 최소 17개의 cell이 채워져 있어야 스도쿠가 가능
        
        bool isRow(int row, int num){
            for(int i=0; i<9; i++){
                if(num == grid[row][i]) return true;
            }
            return false;
        }
        
        bool isCol(int col, int num){
            for(int i=0; i<9; i++){
                if(num == grid[i][col]) return true;
            }
            return false;
        }
        
        /*
        주어진 행 row에 num이 이미 존재하는지 찾는 함수 -> isRow
        주어진 열 col에 num이 이미 존재하는지 찾는 함수 -> isCol
        */
        
        bool isSubGrid(int start_row, int start_col, int num){
            int i, j;
            for (i=start_row; i<start_row+3; i++){
                for(j=start_col; j<start_col+3; j++){
                    if(grid[i][j]==num) return true;
                }
            }
            return false;
        }
        /*
        3x3 sub gird에 num이 이미 존재하는지 찾는 함수
        밑에 함수에서 start_row, start_col을 정의함
        start_row = row - row%3
        start_col = col - col%3
        이렇게 정의하면 
        0~2까지는 0
        3~5까지는 3
        6~8까지는 6
        이라서 3x3 sub grid에서 시작 지점이 항상 일정함
        */ 
        
        bool isVaild(int row, int col, int num){
            int start_row = row - row%3;
            int start_col = col - col%3;
            
            return !isRow(row, num) && !isCol(col, num) && !isSubGrid(start_row, start_col, num);
        }
        /*
        유효성 검사 주어진 행, 열 row, col에 주어진 숫자 num이 이미 존재 하지 않고
        sub gird 3x3에도 존재 하지 않아야 함
        */
        
        bool findEmptyCell(int &row, int &col){
            for(row=0; row<9; row++){
                for(col=0; col<9; col++){
                    if(grid[row][col]==0) return true;
                }
            }
            return false;
        }
        /*
        gird 내에 빈 cell 즉 채워지지 않은 cell을 찾는 함수
        비어 있는 cell을 찾으면 그 cell에 row, col을 외부에 참조 매개변수로 반환
        모든 cell이 채워져 있다면 == 수도쿠 풀이 완료!
        */
        
        bool solve_sudoku(int &call_count){
            int row, col;
            call_count++;
            if(!findEmptyCell(row, col)) return true;
        
            for(int num=1; num<=9; num++){
                if(isVaild(row, col, num)){
                    grid[row][col] = num;
                    if(solve_sudoku(call_count)) return true;
                    grid[row][col] = 0;
                }
            }
            return false;
        }
        /*
        findEmptyCell함수를 호출해 비어있는 cell에 (row,col)을 찾고 반환
        for루프는 1부터 9까지의 숫자를 시도 == 이 숫자는 그리드에 배치할 후보 숫자
        isValid 함수를 호출해 (row,col)에 숫자를 배치할 수 있는지 확인
        -> isValid함수는 특정 숫자가 해당 행, 열, 서브 그리드에 이미 존재하는지 확인하는 함수
        isVaild 함수가 true를 반환하면 == 그 위치에 숫자를 배치하고 solve_sudoku함수를 재귀적으로 호출
        이 과정속에서 모든 비어있는 cell에 대한 시도가 이루어짐
        재귀 호출에서 solve_sudoku가 ture를 반환하면 유효한 숫자가 유효한 자리에 배치된 것
        만약 현재 위치(row,col)에 숫자를 배치하고 solve_sudoku함수에서 fales가 반환되었다면,
        현재 위치에 배치된 숫자를 0으로 설정 == 빈 cell로 초기화 하고 다음 숫자를 시도함
        */
        
        int main() {
            int call_count = 0;
            int filled = 0; // 채워진 셀의 개수
        
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    scanf("%d", &grid[i][j]);
                    if (grid[i][j] > 0) {
                        filled++;
                    }
                }
            }
        
        
            if (!isPossible()) {
                printf("불가능한 스도쿠 퍼즐입니다.");
            } else {
                if (solve_sudoku(call_count)) {
                    printf("성공!");

                } else {
                    printf("실패!");
                }
            }
        
            return 0;
        }
        </code>
    </pre>
    <br><br><br>
    코드 설명입니다.
    <br><br><br>
1. isPossible 메소드에서는 스도쿠 문제 해결이 가능한지 판단합니다.<br><br>
2. isRow, isCol 메소드에서는 특정 행 또는 열에 특정 숫자가 이미 있는지 확인합니다.<br><br>
3. isSubGrid 메소드에서는 3x3 크기의 서브 그리드에 특정 숫자가 이미 있는지 확인합니다.<br><br>
4. isValid 메소드에서는 특정 위치에 특정 숫자를 놓을 수 있는지(즉, 유효한지) 판단합니다.<br><br>
5. findEmptyCell 메소드에서는 비어 있는 셀을 찾습니다.<br><br>
6. solve_sudoku 메소드에서는 스도쿠 문제를 해결합니다.<br><br>
<br><br>
스도쿠 판 입력 받기: main() 함수에서 스도쿠 판을 입력 받습니다. 이때 이미 채워진 셀의 수를 카운트합니다.<br><br>
스도쿠 해결 가능성 확인: 입력 받은 스도쿠 판이 해결 가능한지 isPossible 메소드를 통해 확인합니다. 만약 해결이 불가능하다면 메시지를 출력하고 프로그램을 종료합니다.<br><br>
스도쿠 해결 시도: isPossible 메소드가 true를 반환했다면, solve_sudoku 메소드를 호출하여 스도쿠를 해결합니다. 이 함수는 재귀적으로 호출되며, 스도쿠의 빈 셀을 찾아 유효한 숫자를 놓는 작업을 반복합니다.<br><br>
    <br><br>
    </div>

    <div style="margin: 5% 0%; background-color: rgb(55, 55, 55); color: rgb(242, 253, 253); padding: 1rem; border-radius: 1.5rem;">

        <h4>잘했습니다!</h4>
        <br><br>
        <h4>구현한 c++ 코드는 django 프로젝트에서 실행하기위해서 sudoku_maker.py, sudoku_solver.py에서 실행됩니다.</h4>
        <br><br>
        <h4>해당 코드는 <a href="https://github.com/2023-2-UROP/Back/tree/master/algorithm">https://github.com/2023-2-UROP/Back/tree/master/algorithm</a>에서 확인 할 수 있습니다.</h4>
        <br><br>
        <h4>또한 예시로 구현된 c++ 이외의 언어로도 알고리즘 개발이 가능합니다!</h4>
        <br><br>
        <h4>또한 더 어려운 도전 과제를 원한다면 재귀를 이용하지 않고 알고리즘을 개발해 보길 추천합니다!</h4>
        <br><br> 
        <h4>예시(참고) 코드는 <a href="https://github.com/2023-2-UROP/Algorithm">https://github.com/2023-2-UROP/Algorithm</a>에서 확인해 보실수 있습니다.</h4>
        <br><br>
        <h4>구현한 알고리즘을 통해 api를 만들어 봅시다! 백엔드 개발 가이드를 참고해주세요!</h4>
    </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
    </body>
</html>